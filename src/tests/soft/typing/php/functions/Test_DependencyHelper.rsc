module tests::soft::typing::php::functions::Test_DependencyHelper

import lang::php::analysis::cfg::Label;
import soft::typing::php::constraints::ConstraintHelper;
import soft::typing::php::constraints::GetConstraints;

import tests::soft::typing::php::constraints::Test_GetConstraints_Helper;
import tests::soft::typing::php::helper::Test_SetComparator;

import soft::typing::php::functions::DependencyHelpers_OldInterface;
import soft::typing::php::functions::DependencyHelpers;
import IO;

import soft::typing::php::declarations::PublicDataTypes;

private loc rootP=|file:///Users/apil/Dropbox/Scripts|;

public bool assertEquals(TypeRoot t1,TypeRoot t2)
{
	return assertEquals(t1,t2,"TypeRoot","resolveFlow");
}

public bool assertEquals(set[Constraint] soln,set[Constraint] expect)
{
	return assertEquals(soln,expect,"Constraint","resolveDependencies");
}

test bool testdh1()
{
	//Test DependencyHelper.resolveFlow method
	Lab l1=lab(1);
	Lab l2=lab(2);
	Lab l3=lab(3);
	
	Constraint c1=yieldFlow(l1,l2);
	Constraint c2=yieldFlow(l2,l3);
	Constraint c3=yieldType(l3,typeSet({Int()}));
	
	set[Constraint] ccs={c1,c2,c3};
	
	TypeRoot t=resolveFlow(l1,ccs);
	
	return assertEquals(t,typeSet({Int()}));
}

test bool test2()
{
	//One more test for DependencyHelper.resolveFlow method
	Lab l1=lab(1);
	Lab l2=lab(2);
	Lab l3=lab(3);
	Lab l4=lab(4);
	Lab l5=lab(5);
	
	Constraint c2_4=yieldFlow(l2,l4);
	Constraint c1_3=yieldFlow(l1,l3);
	Constraint c4_5=yieldFlow(l4,l5);
	Constraint c5_5=yieldType(l5,typeSet({Int(),Bool()}));
	
	TypeRoot t=resolveFlow(l2,{c2_4,c1_3,c4_5,c5_5});
	
	return assertEquals(t,typeSet({Int(),Bool()}));
}

test bool test3()
{
	//One more test for DependencyHelper.resolveFlow method, Attempt to throw an exception
	//because there is a non-terminating sequence of constraints
	Lab l1=lab(1);
	Lab l2=lab(2);
	Lab l3=lab(3);
	Lab l4=lab(4);
	Lab l5=lab(5);
	
	Constraint c2_4=yieldFlow(l2,l4);
	Constraint c1_3=yieldFlow(l1,l3);
	Constraint c4_5=yieldFlow(l4,l5);
	Constraint c5_5=yieldType(l5,typeSet({Int(),Bool()}));
	try
	{
		TypeRoot v=resolveFlow(l1,{c2_4,c1_3,c4_5,c5_5});
		return assertEquals(v,nullTypeRoot(),"TypeRoot","resolveFlow");
	}catch str x:
	{
		if(x=="Resolving dependency for Label: lab(3) threw a null-constraint. Error loc: 34872783")
		{
			return true;
		}
		else
		{
			printIndLn("exception: <x>");
			return false;
		}
	}
	
}

test bool test4_DH()
{
	//Test DependencyHelper.resolveDependencies method
	Lab l1=lab(1);
	Lab l2=lab(2);
	Lab l3=lab(3);
	Lab l4=lab(4);
	Lab l5=lab(5);
	
	tB=typeSet({Int(),Bool()});
	//tA=typeSingleton(Int());
	tA=typeSet({Int()});
	
	c1=yieldFlow(l1,l2); c2=yieldFlow(l2,l3); c3=yieldType(l3,tA);
	c4=yieldType(l4,tB); c5=expectType(l2,tA);
	
	ccs={c1,c2,c5,c3,c4};
	
	set[Constraint] expected={yieldType(l2,tA),yieldType(l3,tA),
			yieldType(l1,tA),yieldType(l4,tB),expectType(l2,tA)};
	
	result=resolveDependencies(ccs);

	return assertEquals(result,expected);
	
}

test bool testTernaryExpr1()
{
	Lab l1=lab(1);
	Lab l2=lab(2);
	Lab l3=lab(3);
	
	t2=typeSet({String()});
	t3=typeSet({Int()});
	
	//this constraint is produced when the constraints extractor
	//encounters a ternary expression
	c1=yieldType(l1,fromLabels({l2,l3}));
	
	//constraints defining typeroots of lab(2) and lab(3)
	c2=yieldType(l2,t2);
	c3=yieldType(l3,t3);
	
	ccs={c1,c2,c3};
	expected={yieldType(l1,typeSet({String(),Int()})),
			  yieldType(l2,typeSet({String()})),
			  yieldType(l3,typeSet({Int()}))
			  };
	result=resolveDependencies(ccs);
	
	//assert that the typeroot extracted for lab(1) is typeSet({String(),Int()})
	return assertEquals(result,expected);
	
	
}

test bool test5()
{
	//loc fileP=rootP+"/Array1.php";
	/* Content of file: 
	<?
		$a[1]="a";
	?>
	*/
	
	str expr="$a[1]=\"a\"";

	ccs=extractConstraints(getLabeledStmt(expr));	
	
	//evaluate the resultant set of constraints
	//pass only constraints that are either yieldType/yieldFlow
	result=
		resolveDependencies({cc| cc<- ccs,(cc is yieldType || cc is yieldFlow)});
		
	
	expected={
		
		yieldType(lab(3),typeSet({String()})),
		yieldType(lab(2),typeSet({Int()})),
		/*
		
		expectType(lab(2),typeSet({String(),Int()})),
		expectType(lab(1),typeSet({Array(Any())})),
		
		The above constraints are normally generated by 
		func: extractConstraints, but they will be dealt
		with seperately...
		*/

		
		yieldType(lab(4),typeSet({String()})),
		yieldType(lab(1),typeSet({Array(String())}))
	};
	
	return assertEquals(result,expected);
}

test bool test5_1()
{
	ccs={
		yieldType(lab(4),typeSet({String()})),
		
		yieldType(lab(1),toArray(lab(4))),
		yieldType(lab(3),fromArray(lab(1)))
	};
	result=resolveDependencies(ccs);

	expected={
		yieldType(lab(4),typeSet({String()})),
		yieldType(lab(1),typeSet({Array(String())})),
		yieldType(lab(3),typeSet({String()}))
	};
	
	return assertEquals(result,expected);
}
test bool test5_2()
{

	ccs={ 
		yieldFlow(lab(1),lab(4)),
		yieldType(lab(4),fromArray(lab(2))),
		yieldType(lab(2),typeSet({Array(Bool( ) ) }))
	};

	result=resolveDependencies(ccs);
	
	expected={
		yieldType(lab(1),typeSet({Bool( )})),
		yieldType(lab(4),typeSet({Bool( ) })),
		yieldType(lab(2),typeSet({Array(Bool( )) }))
	};
	
	return assertEquals(result,expected);
}
test bool test6()
{
	//loc fileP=rootP+"/Array2.php";
	/* Content of file: 
	<?
		$b=$a[1];
	?>
	*/
	
	str expr="$b=$a[1]";
	ccs=extractConstraints(getLabeledStmt(expr));
	
	TypeEnvironment entry=(var("a"):typeSet({Array(Bool())}));	
	
	loc foobar=|file:///|;

	//evaluate the resultant set of constraints
	result=
		resolveDependencies(	//use the new resolveDependencies signature..
			foobar,
			{cc|cc<-ccs,(cc is yieldType || cc is yieldFlow)},
			entry,
			"normal"
		);
	
	//list the expected set of constraints	
	expected=
		{yieldType(lab(3),typeSet({Int()})),
		
		/*
		See the cause in test5();
		expectType(lab(2),typeSet({Array(Any())})),
		expectType(lab(3),typeSet({String(),Int()})),
		
		Will be dealt with seperately later on in the algorithm
		*/
		
		
		yieldType(lab(4),typeSet({Bool( ) })),
		yieldType(lab(5),typeSet({Bool( ) })),
		yieldType(lab(2),typeSet({Array(Bool( ))})),
		yieldType(lab(1),typeSet({Bool()}))
	};

	return assertEquals(result.ccs,expected);
	
}

test bool test6_1()
{

	//loc fileP=rootP+"/Array3.php";
	/* Content of file: 
	<?
		$b=count($a);
	?>
	*/
	
	
	
	ccs=extractConstraints(
		getLabeledStmt(
			"$b=count($a)"
		)
	);
	
	TypeEnvironment entry=(var("a"):typeSet({Array(Any())}));	
	
	loc foobar=|file:///|;
	
	result=
		resolveDependencies(	//use the new resolveDependencies signature..
			foobar,
			ccs,
			entry,
			"normal"
		);
	
	expected={
		yieldType(lab(4),typeSet({Int()})),
		yieldType(lab(3),typeSet({Int()})),
		yieldType(lab(1),typeSet({Int()})),
		yieldType(lab(2),typeSet({Array(Any())})),
		expectType(
			lab(2),
			typeSet({Array(Any())})
		)
	};

	return assertEquals(result.ccs,expected);
}
test bool test7()
{
	//experiment with array types in typesets
	ccs={
		yieldType(lab(4),typeSet({String()})),
		
		yieldType(lab(1),toArray(lab(4))),
		yieldType(lab(3),fromArray(lab(1)))
	};
	result=resolveDependencies(ccs);

	expected={
		yieldType(lab(4),typeSet({String()})),
		yieldType(lab(1),typeSet({Array(String())})),
		yieldType(lab(3),typeSet({String()}))
	};
	
	return assertEquals(result,expected);
	
	
}


test bool test9()
{
	/*
	str expr="array(\"a\",1,true)";
	*/
	set[Constraint] ccs={
	  yieldType(
	    lab(4),
	    toArraySet({
	        lab(1),
	        lab(2),
	        lab(3)
	      })),
	  yieldType(
	    lab(1),
	    typeSet({String()})),
	  yieldType(
	    lab(2),
	    typeSet({Int()})),
	  yieldType(
	    lab(3),
	    typeSet({Bool()}))
	};

	result=resolveDependencies(ccs);
	
	expected={
	  yieldType(
	    lab(4),
	    typeSet({
	        Array(String()),
	        Array(Int()),
	        Array(Bool())
	      })),
	  yieldType(
	    lab(1),
	    typeSet({String()})),
	  yieldType(
	    lab(2),
	    typeSet({Int()})),
	  yieldType(
	    lab(3),
	    typeSet({Bool()}))
	};
	
	return assertEquals(result,expected);
}
test bool test10()
{
	str expr="$a=array(\"1\",2,true)";
	set[Constraint] ccs={
	  yieldFlow(
	    lab(1),
	    lab(5)),
	  yieldFlow(
	    lab(6),
	    lab(5)),
	  yieldType(
	    lab(5),
	    toArraySet({
	        lab(2),
	        lab(3),
	        lab(4)
	      })),
	  yieldType(
	    lab(2),
	    typeSet({String()})),
	  yieldType(
	    lab(3),
	    typeSet({Int()})),
	  yieldType(
	    lab(4),
	    typeSet({Bool()}))
	};
	
	result=resolveDependencies(ccs);
	
	expected={
	  yieldType(
	    lab(1),
	    typeSet({
	        Array(String()),
	        Array(Int()),
	        Array(Bool())
	      })),

	  yieldType(
	    lab(6),
	    typeSet({
	        Array(String()),
	        Array(Int()),
	        Array(Bool())
	      })),

	  yieldType(
	    lab(5),
	    typeSet({
	        Array(String()),
	        Array(Int()),
	        Array(Bool())
	      })),
	  yieldType(
	    lab(2),
	    typeSet({String()})),
	  yieldType(
	    lab(3),
	    typeSet({Int()})),
	  yieldType(
	    lab(4),
	    typeSet({Bool()}))
	};

	return assertEquals(result,expected);	
}

test bool test10_1()
{
	str expr="$a=array(\"ab\",\"cd\",\"ef\")";
	set[Constraint] ccs={
	  yieldFlow(
	    lab(1),
	    lab(5)),
	  yieldFlow(
	    lab(6),
	    lab(5)),
	  yieldType(
	    lab(5),
	    toArraySet({
	        lab(2),
	        lab(3),
	        lab(4)
	      })),
	  yieldType(
	    lab(2),
	    typeSet({String()})),
	  yieldType(
	    lab(3),
	    typeSet({String()})),
	  yieldType(
	    lab(4),
	    typeSet({String()}))
	};
	
	result=resolveDependencies(ccs);
	
	expected={
	  yieldType(
	    lab(1),
	    typeSet({Array(String())})),

	  yieldType(
	    lab(6),
	    typeSet({Array(String())})),

	  yieldType(
	    lab(5),
	    typeSet({Array(String())})),
	  yieldType(
	    lab(2),
	    typeSet({String()})),
	  yieldType(
	    lab(3),
	    typeSet({String()})),
	  yieldType(
	    lab(4),
	    typeSet({String()}))
	};

	return assertEquals(result,expected);	
}


test bool test11()
{
	/*
	str expr="$a=2*$b[2]";
	*/
	set[Constraint] ccs={
	  yieldFlow(
	    lab(1),
	    lab(6)),
	  yieldFlow(
	    lab(7),
	    lab(6)),
	  expectType(
	    lab(2),
	    typeSet({Num()})),
	  expectType(
	    lab(5),
	    typeSet({Num()})),
	  yieldType(
	    lab(6),
	    typeSet({Num()})),
	  yieldType(
	    lab(2),
	    typeSet({Int()})),
	  expectType(
	    lab(3),
	    toArray(Any())),
	  expectType(
	    lab(4),
	    typeSet({
	        Int(),
	        String()
	      })),
	  yieldType(
	    lab(5),
	    fromArray(lab(3))),
	  yieldType(
	    lab(4),
	    typeSet({Int()}))
	};
	
	//add yieldType for the array variable
	ccs += yieldType(lab(3),typeSet({Array(Any())}));
	
	result=resolveDependencies({cc|cc<-ccs,cc is yieldType||cc is yieldFlow});
	
	expected={
	
	  yieldType(
	    lab(1),
	    typeSet({Num()})),
	  yieldType(
	    lab(7),
	    typeSet({Num()})),
	   /*
	  expectType(
	    lab(2),
	    typeSet({Num()})),
	    
	  expectType(
	    lab(5),
	    typeSet({Num()})),
	    
	    will be dealt with seperately
	  */
	  yieldType(
	    lab(6),
	    typeSet({Num()})),
	  yieldType(
	    lab(2),
	    typeSet({Int()})),
	 /*	   
	  expectType(
	    lab(3),
	    typeSingleton(Array(Any()))),
	  
	  expectType(
	    lab(4),
	    typeSet({
	        Int(),
	        String()
	      })),
	  */
	  yieldType(
	    lab(5),
	    typeSet({Any()})),
	  yieldType(
	    lab(4),
	    typeSet({Int()})),
	  yieldType(
	  	lab(3),
	  	typeSet({Array(Any())}))
	  	
	};
	
	return assertEquals(result,expected);
}


test bool test13()
{
	/*
	str expr="$a[2]=$b[2]";
	
	1. Removed all expectType constraints
	2. Reoved yieldTypes for indices of arrays, because they don't really play
	   any active roles.
	3. Added yieldType for lab(4), which is associted with the array variable $b,
	
	The net constraints to analyse are (in simplified view)
	1. lab(1) <-- toArray(lab(6)) 
	   [$a is an array whose type is determined by the type of $b]
	
	2. lab(3) <-- fromArray(lab(1))
	   [ The type of the expression: $a[2] is determined by the type of $a ]
	   
	3. lab(6) <-- fromArray(lab(4))
	   [ The type of expression: $b[2] is determined by the type of $b ], and finally
	
	4. lab(4) := {Array(Float()), Array(Int())}
		[ It has been determined that array b holds elements of type: float, and int   	
	*/
	
	set[Constraint] ccs={
	  yieldType(
	    lab(1),
	    toArray(lab(6))),
	  yieldType(
	    lab(3),
	    fromArray(lab(1))),
	  yieldType(
	    lab(6),
	    fromArray(lab(4))),
	  //Add this artificially to complete the process...
	  yieldType(
	  	lab(4),
	  	typeSet({Array(Float()),Array(Int())}))
	};
	
	result=resolveDependencies(ccs);
	
	expected={
	  yieldType(
	    lab(1),
	    typeSet({Array(Float()),Array(Int())})),
	  yieldType(
	    lab(3),
	    typeSet({Float(),Int()})),
	  yieldType(
	    lab(6),
	    typeSet({Float(),Int()})),
	  //Add this artificially to complete the process...
	  yieldType(
	  	lab(4),
	  	typeSet({Array(Float()),Array(Int())}))
	
	};

	return assertEquals(result,expected);
}

test bool testToArray()
{
	ccs={
		yieldType(lab(0),toArray(lab(1))),
		yieldType(lab(1),toArray(lab(2))),
		yieldType(lab(2),typeSet({Int()}))
	};
	
	result=resolveDependencies(ccs);
	
	expected={
		yieldType(lab(0),typeSet({Array(Array(Int()))
		})),
		yieldType(lab(1),typeSet({Array(Int())
		})),
		yieldType(lab(2),typeSet({Int()
		}))
	};
	
	return assertEquals(result,expected);

}

test bool testFromArray()
{
	ccs={
		yieldType(lab(0),typeSet({Array(Array(Int()))
		})),
		yieldType(lab(1),typeSet({Array(Int())
		})),
		yieldType(lab(2),typeSet({Int()
		})),

		yieldType(lab(10),fromArray(lab(0))),
		yieldType(lab(11),fromArray(lab(1)))
		
	};					
	
	result=resolveDependencies(ccs);
	expected={

		yieldType(lab(0),typeSet({Array(Array(Int()))
		})),
		yieldType(lab(1),typeSet({Array(Int())
		})),
		yieldType(lab(2),typeSet({Int()
		})),

		yieldType(lab(10),typeSet({Array(Int())
		})),
		
		yieldType(lab(11),typeSet({Int()
		}))
	};
	return assertEquals(result,expected);
		
}

test bool testNestedToArray()
{
	ccs={
		yieldType(lab(0),toArray(lab(1))),
		yieldType(lab(1),toArray(lab(2))),
		yieldType(lab(2),typeSet({Int(),String()}))
	};
	
	result=resolveDependencies(ccs);
	
	expected={
		yieldType(lab(0),typeSet({
			Array(Array(Int())),
			Array(Array(String()))
		})),
		yieldType(lab(1),typeSet({
			Array(Int()),
			Array(String())
		})),
		yieldType(lab(2),typeSet({
			Int(),
			String()
		}))
	};
	
	return assertEquals(result,expected);
		
}
test bool testNestedFromArray()
{
	ccs={
		yieldType(lab(0),typeSet({
			Array(Array(Int())),
			Array(Array(String()))
		})),
		yieldType(lab(1),typeSet({
			Array(Int()),
			Array(String())
		})),
		yieldType(lab(2),typeSet({
			Int(),
			String()
		})),

		yieldType(lab(10),fromArray(lab(0))),
		yieldType(lab(11),fromArray(lab(1)))
		
	};					

	result=resolveDependencies(ccs);
	expected={
		//got from the first three constraints
		yieldType(lab(0),typeSet({
			Array(Array(Int())),
			Array(Array(String()))
		})),
		yieldType(lab(1),typeSet({
			Array(Int()),
			Array(String())
		})),
		yieldType(lab(2),typeSet({
			Int(),
			String()
		})),
		
		//got from the last two
		yieldType(lab(11),typeSet({
			Int(),
			String()
		})),
		yieldType(lab(10),typeSet({
			Array(Int()),
			Array(String())
		}))
	};
	
	return assertEquals(result,expected);
		
}

test bool testToFromArrayForTypeSingleton()
{
	ccs={
		
		yieldType(lab(0),typeSet({Int()})),
		yieldType(lab(1),toArray(lab(0))),
		yieldType(lab(2),fromArray(lab(1)))
	};
	
	result=resolveDependencies(ccs);
	
	expected={
		yieldType(lab(0),typeSet({Int()})),
		yieldType(lab(1),typeSet({Array(Int())})),
		yieldType(lab(2),typeSet({Int()}))
	};
	
	return assertEquals(result,expected);
}

test bool testToFromArrayForTypeSet()
{
	ccs={
		
		yieldType(lab(0),typeSet({Int(),String()})),
		yieldType(lab(1),toArray(lab(0))),
		yieldType(lab(2),fromArray(lab(1)))
	};
	
	result=resolveDependencies(ccs);
	
	expected={
		yieldType(lab(0),typeSet({Int(),String()})),
		yieldType(lab(1),typeSet({Array(Int()),Array(String())})),
		yieldType(lab(2),typeSet({Int(),String()}))
	};
	
	return assertEquals(result,expected);
}

test bool testToArraySet_1()
{
	ccs={
		yieldType(lab(0),toArraySet({lab(1),lab(2)})),
		yieldType(lab(1),typeSet({Int()})),
		yieldType(lab(2),typeSet({Int()}))
		
	};
	
	result=resolveDependencies(ccs);
	
	expected={
		yieldType(lab(0),typeSet({Array(Int())})),
		yieldType(lab(1),typeSet({Int()})),
		yieldType(lab(2),typeSet({Int()}))
		
	};
	
	return assertEquals(result,expected);
}

test bool testToArraySet_2()
{
	ccs={
		yieldType(lab(0),toArraySet({lab(1),lab(2)})),
		yieldType(lab(1),typeSet({Int()})),
		yieldType(lab(2),typeSet({String()}))
		
	};
	
	result=resolveDependencies(ccs);
	
	expected={
		yieldType(lab(0),typeSet({Array(Int()),Array(String())})),
		yieldType(lab(1),typeSet({Int()})),
		yieldType(lab(2),typeSet({String()}))
		
	};
	
	return assertEquals(result,expected);
}

test bool testToArraySet_3()
{
	ccs={
		yieldType(lab(0),toArraySet({lab(1),lab(2)})),
		yieldType(lab(1),typeSet({Int(),Bool()})),
		yieldType(lab(2),typeSet({Int()}))
		
	};
	
	result=resolveDependencies(ccs);
	
	expected={
		yieldType(lab(0),typeSet({Array(Int()),Array(Bool())})),
		yieldType(lab(1),typeSet({Int(),Bool()})),
		yieldType(lab(2),typeSet({Int()}))
		
	};
	
	return assertEquals(result,expected);
}

test bool testToArraySet_4()
{
	ccs={
		yieldType(lab(0),toArraySet({lab(1),lab(2)})),
		yieldType(lab(1),typeSet({Int(),Array(Bool())})),
		yieldType(lab(2),typeSet({Int()}))
		
	};
	
	result=resolveDependencies(ccs);
	
	expected={
		yieldType(lab(0),typeSet({Array(Int()),Array(Array(Bool()))})),
		yieldType(lab(1),typeSet({Int(),Array(Bool())})),
		yieldType(lab(2),typeSet({Int()}))
		
	};
	
	return assertEquals(result,expected);
}
